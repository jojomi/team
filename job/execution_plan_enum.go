// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package job

import (
	"fmt"

	"github.com/juju/errors"
)

const (
	// ExecutionPlanSkip is a ExecutionPlan of type Skip.
	ExecutionPlanSkip ExecutionPlan = iota
	// ExecutionPlanLogDone is a ExecutionPlan of type LogDone.
	ExecutionPlanLogDone
	// ExecutionPlanExecute is a ExecutionPlan of type Execute.
	ExecutionPlanExecute
)

var ErrInvalidExecutionPlan = errors.New("not a valid ExecutionPlan")

const _ExecutionPlanName = "skiplogDoneexecute"

var _ExecutionPlanMap = map[ExecutionPlan]string{
	ExecutionPlanSkip:    _ExecutionPlanName[0:4],
	ExecutionPlanLogDone: _ExecutionPlanName[4:11],
	ExecutionPlanExecute: _ExecutionPlanName[11:18],
}

// String implements the Stringer interface.
func (x ExecutionPlan) String() string {
	if str, ok := _ExecutionPlanMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ExecutionPlan(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ExecutionPlan) IsValid() bool {
	_, ok := _ExecutionPlanMap[x]
	return ok
}

var _ExecutionPlanValue = map[string]ExecutionPlan{
	_ExecutionPlanName[0:4]:   ExecutionPlanSkip,
	_ExecutionPlanName[4:11]:  ExecutionPlanLogDone,
	_ExecutionPlanName[11:18]: ExecutionPlanExecute,
}

// ParseExecutionPlan attempts to convert a string to a ExecutionPlan.
func ParseExecutionPlan(name string) (ExecutionPlan, error) {
	if x, ok := _ExecutionPlanValue[name]; ok {
		return x, nil
	}
	return ExecutionPlan(0), fmt.Errorf("%s is %w", name, ErrInvalidExecutionPlan)
}
